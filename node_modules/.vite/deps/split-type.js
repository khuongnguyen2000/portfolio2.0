import "./chunk-RSJERJUL.js";

// node_modules/split-type/dist/index.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function extend(target, object) {
  return Object.getOwnPropertyNames(Object(target)).reduce(function(extended, key) {
    var currentValue = Object.getOwnPropertyDescriptor(Object(target), key);
    var newValue = Object.getOwnPropertyDescriptor(Object(object), key);
    return Object.defineProperty(extended, key, newValue || currentValue);
  }, {});
}
function parseSettings(settings) {
  var object = extend(settings);
  if (object.types || object.split) {
    object.types = object.types || object.split;
  }
  if (object.absolute || object.position) {
    object.absolute = object.absolute || /absolute/.test(settings.position);
  }
  return object;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isLength(value) {
  return typeof value === "number" && value > -1 && value % 1 === 0;
}
function isArrayLike(value) {
  return isObject(value) && isLength(value.length);
}
function toArray(value) {
  if (Array.isArray(value))
    return value;
  if (value == null)
    return [];
  return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];
}
function isNode(input) {
  return isObject(input) && /^(1|3|11)$/.test(input.nodeType);
}
function isString(value) {
  return typeof value === "string";
}
function flatten(obj) {
  return toArray(obj).reduce(function(result, item) {
    return result.concat(toArray(item));
  }, []);
}
function getTargetElements(target) {
  var elements = target;
  if (isString(target)) {
    if (/^(#[a-z]\w+)$/.test(target.trim())) {
      elements = document.getElementById(target.trim().slice(1));
    } else {
      elements = document.querySelectorAll(target);
    }
  }
  return flatten(elements).filter(isNode);
}
function Data(owner, key, value) {
  var data = {};
  var id = null;
  if (isObject(owner)) {
    id = owner[Data.expando] || (owner[Data.expando] = ++Data.uid);
    data = Data.cache[id] || (Data.cache[id] = {});
  }
  if (value === void 0) {
    if (key === void 0) {
      return data;
    }
    return data[key];
  } else if (key !== void 0) {
    data[key] = value;
    return value;
  }
}
Data.expando = "splitType".concat(new Date() * 1);
Data.cache = {};
Data.uid = 0;
function RemoveData(element) {
  var id = element && element[Data.expando];
  if (id) {
    delete element[id];
    delete Data.cache[id];
  }
}
function forEach(collection, callback) {
  var arr = toArray(collection);
  for (var len = arr.length, i = 0; i < len; i++) {
    callback(arr[i], i, arr);
  }
}
function toWords(string) {
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ";
  string = string ? String(string) : "";
  return string.split(separator);
}
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
var rsComboSymbolsRange = "\\u20d0-\\u20f0";
var rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[".concat(rsAstralRange, "]");
var rsCombo = "[".concat(rsComboMarksRange).concat(rsComboSymbolsRange, "]");
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:".concat(rsCombo, "|").concat(rsFitz, ")");
var rsNonAstral = "[^".concat(rsAstralRange, "]");
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ = "\\u200d";
var reOptMod = "".concat(rsModifier, "?");
var rsOptVar = "[".concat(rsVarRange, "]?");
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:".concat(["".concat(rsNonAstral).concat(rsCombo, "?"), rsCombo, rsRegional, rsSurrPair, rsAstral].join("|"), "\n)");
var reUnicode = RegExp("".concat(rsFitz, "(?=").concat(rsFitz, ")|").concat(rsSymbol).concat(rsSeq), "g");
var unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];
var reHasUnicode = RegExp("[".concat(unicodeRange.join(""), "]"));
function asciiToArray(string) {
  return string.split("");
}
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
function toString(value) {
  return value == null ? "" : String(value);
}
function toChars(string) {
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  string = toString(string);
  if (string && isString(string)) {
    if (!separator && hasUnicode(string)) {
      return stringToArray(string);
    }
  }
  return string.split(separator);
}
function createElement(name, attributes) {
  var element = document.createElement(name);
  if (!attributes) {
    return element;
  }
  Object.keys(attributes).forEach(function(attribute) {
    var value = attributes[attribute];
    if (value === null)
      return;
    if (attribute === "textContent" || attribute === "innerHTML") {
      element[attribute] = value;
    } else if (attribute === "children") {
      forEach(value, function(child) {
        if (isNode(child))
          element.appendChild(child);
      });
    } else {
      element.setAttribute(attribute, String(value).trim());
    }
  });
  return element;
}
function parseTypes(value) {
  var types = isString(value) || Array.isArray(value) ? String(value) : "";
  return {
    lines: /line/i.test(types),
    words: /word/i.test(types),
    chars: /(char)|(character)/i.test(types)
  };
}
function getTextContent(element, LINE_BREAK_SYMBOL) {
  var brTag = /<br\s*\/?>/g;
  var textContent = element.textContent;
  if (LINE_BREAK_SYMBOL) {
    var innerHTML = element.innerHTML;
    var tempDiv = document.createElement("div");
    tempDiv.innerHTML = innerHTML.replace(brTag, " ".concat(LINE_BREAK_SYMBOL, " "));
    textContent = tempDiv.textContent;
  }
  return textContent.replace(/\s+/g, " ").trim();
}
var defaults = {
  splitClass: "",
  lineClass: "line",
  wordClass: "word",
  charClass: "char",
  types: "lines, words, chars",
  absolute: false,
  tagName: "div"
};
var createFragment = function createFragment2() {
  return document.createDocumentFragment();
};
var createTextNode = function createTextNode2(str) {
  return document.createTextNode(str);
};
function splitSingleElement(element, settings) {
  settings = extend(defaults, settings);
  var types = parseTypes(settings.types);
  var TAG_NAME = settings.tagName;
  var BR_SYMBOL = "B".concat(new Date() * 1, "R");
  var isAbsolute = settings.position === "absolute" || settings.absolute;
  var lines = [];
  var words = [];
  var chars = [];
  var splitText;
  splitText = types.lines ? createElement("div") : createFragment();
  var TEXT_CONTENT = getTextContent(element, BR_SYMBOL);
  words = toWords(TEXT_CONTENT).reduce(function(result, WORD, idx, arr) {
    var wordElement;
    var characterElementsForCurrentWord;
    if (WORD === BR_SYMBOL) {
      splitText.appendChild(createElement("br"));
      return result;
    }
    if (types.chars) {
      characterElementsForCurrentWord = toChars(WORD).map(function(CHAR) {
        return createElement(TAG_NAME, {
          class: "".concat(settings.splitClass, " ").concat(settings.charClass),
          style: "display: inline-block;",
          textContent: CHAR
        });
      });
      chars = chars.concat(characterElementsForCurrentWord);
    }
    if (types.words || types.lines) {
      wordElement = createElement(TAG_NAME, {
        class: "".concat(settings.wordClass, " ").concat(settings.splitClass),
        style: "display: inline-block; position: ".concat(types.words ? "relative" : "static"),
        children: types.chars ? characterElementsForCurrentWord : null,
        textContent: !types.chars ? WORD : null
      });
      splitText.appendChild(wordElement);
    } else {
      forEach(characterElementsForCurrentWord, function(characterElement) {
        splitText.appendChild(characterElement);
      });
    }
    if (idx !== arr.length - 1) {
      splitText.appendChild(createTextNode(" "));
    }
    return types.words ? result.concat(wordElement) : result;
  }, []);
  element.innerHTML = "";
  element.appendChild(splitText);
  if (!isAbsolute && !types.lines) {
    return {
      chars,
      words,
      lines: []
    };
  }
  var wordsInEachLine = [];
  var wordsInCurrentLine = [];
  var lineHeight;
  var elementHeight;
  var elementWidth;
  var contentBox;
  var lineOffsetY;
  var nodes = Data(element, "nodes", element.getElementsByTagName(TAG_NAME));
  var parent = element.parentElement;
  var nextSibling = element.nextElementSibling;
  var cs = window.getComputedStyle(element);
  var align = cs.textAlign;
  if (isAbsolute) {
    contentBox = {
      left: splitText.offsetLeft,
      top: splitText.offsetTop,
      width: splitText.offsetWidth
    };
    elementWidth = element.offsetWidth;
    elementHeight = element.offsetHeight;
    Data(element).cssWidth = element.style.width;
    Data(element).cssHeight = element.style.height;
  }
  forEach(nodes, function(node) {
    if (node === splitText)
      return;
    var isWord = node.parentElement === splitText;
    var wordOffsetY;
    if (types.lines && isWord) {
      wordOffsetY = Data(node, "top", node.offsetTop);
      if (wordOffsetY !== lineOffsetY) {
        lineOffsetY = wordOffsetY;
        wordsInEachLine.push(wordsInCurrentLine = []);
      }
      wordsInCurrentLine.push(node);
    }
    if (isAbsolute) {
      Data(node).top = wordOffsetY || node.offsetTop;
      Data(node).left = node.offsetLeft;
      Data(node).width = node.offsetWidth;
      Data(node).height = lineHeight || (lineHeight = node.offsetHeight);
    }
  });
  if (parent) {
    parent.removeChild(element);
  }
  if (types.lines) {
    splitText = createFragment();
    lines = wordsInEachLine.map(function(wordsInThisLine) {
      var lineElement = createElement(TAG_NAME, {
        class: "".concat(settings.splitClass, " ").concat(settings.lineClass),
        style: "display: block; text-align: ".concat(align, "; width: 100%;")
      });
      splitText.appendChild(lineElement);
      if (isAbsolute) {
        Data(lineElement).type = "line";
        Data(lineElement).top = Data(wordsInThisLine[0]).top;
        Data(lineElement).height = lineHeight;
      }
      forEach(wordsInThisLine, function(wordElement, idx, arr) {
        if (types.words) {
          lineElement.appendChild(wordElement);
        } else if (types.chars) {
          forEach(wordElement.children, function(charNode) {
            lineElement.appendChild(charNode);
          });
        } else {
          lineElement.appendChild(createTextNode(wordElement.textContent));
        }
        if (idx !== arr.length - 1) {
          lineElement.appendChild(createTextNode(" "));
        }
      });
      return lineElement;
    });
    element.replaceChild(splitText, element.firstChild);
  }
  if (isAbsolute) {
    element.style.width = "".concat(element.style.width || elementWidth, "px");
    element.style.height = "".concat(elementHeight, "px");
    forEach(nodes, function(node) {
      var isLineNode = Data(node).type === "line";
      var isChildOfLineNode = !isLineNode && Data(node.parentElement).type === "line";
      node.style.top = "".concat(isChildOfLineNode ? 0 : Data(node).top, "px");
      node.style.left = isLineNode ? "".concat(contentBox.left, "px") : "".concat(Data(node).left - (isChildOfLineNode ? contentBox.left : 0), "px");
      node.style.height = "".concat(Data(node).height, "px");
      node.style.width = isLineNode ? "".concat(contentBox.width, "px") : "".concat(Data(node).width, "px");
      node.style.position = "absolute";
    });
  }
  if (parent) {
    if (nextSibling)
      parent.insertBefore(element, nextSibling);
    else
      parent.appendChild(element);
  }
  return {
    lines,
    words: types.words ? words : [],
    chars
  };
}
var _defaults = extend(defaults, {});
var SplitType = function() {
  _createClass(SplitType2, null, [{
    key: "defaults",
    get: function get() {
      return _defaults;
    },
    set: function set(options) {
      _defaults = extend(_defaults, parseSettings(options));
    }
  }]);
  function SplitType2(target, options) {
    _classCallCheck(this, SplitType2);
    this.isSplit = false;
    this.settings = extend(_defaults, parseSettings(options));
    this.elements = getTargetElements(target) || [];
    if (this.elements.length) {
      this.originals = this.elements.map(function(element) {
        return Data(element, "html", Data(element).html || element.innerHTML);
      });
      if (this.settings.types) {
        this.split();
      }
    }
  }
  _createClass(SplitType2, [{
    key: "split",
    value: function split(options) {
      var _this = this;
      this.revert();
      this.lines = [];
      this.words = [];
      this.chars = [];
      var scrollPos = [window.pageXOffset, window.pageYOffset];
      if (options !== void 0) {
        this.settings = extend(this.settings, parseSettings(options));
      }
      this.elements.forEach(function(element) {
        var _split2 = splitSingleElement(element, _this.settings), lines = _split2.lines, words = _split2.words, chars = _split2.chars;
        _this.lines = _this.lines.concat(lines);
        _this.words = _this.words.concat(words);
        _this.chars = _this.chars.concat(chars);
        Data(element).isSplit = true;
      });
      this.isSplit = true;
      window.scrollTo(scrollPos[0], scrollPos[1]);
      this.elements.forEach(function(element) {
        var nodes = Data(element).nodes || [];
        toArray(nodes).forEach(RemoveData);
      });
    }
  }, {
    key: "revert",
    value: function revert() {
      var _this2 = this;
      if (this.isSplit) {
        this.lines = null;
        this.words = null;
        this.chars = null;
      }
      this.elements.forEach(function(element) {
        if (Data(element).isSplit && Data(element).html) {
          element.innerHTML = Data(element).html;
          element.style.height = Data(element).cssHeight || "";
          element.style.width = Data(element).cssWidth || "";
          _this2.isSplit = false;
        }
      });
    }
  }]);
  return SplitType2;
}();
var dist_default = SplitType;

// dep:split-type
var split_type_default = dist_default;
export {
  split_type_default as default
};
//# sourceMappingURL=split-type.js.map

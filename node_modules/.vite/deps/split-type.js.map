{
  "version": 3,
  "sources": ["../../split-type/dist/index.js", "dep:split-type"],
  "sourcesContent": ["/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.2.5\n * @author Luke Peavey <lwpeavey@gmail.com>\n */\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */\nfunction extend(target, object) {\n  return Object.getOwnPropertyNames(Object(target)).reduce(function (extended, key) {\n    var currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n    var newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n    return Object.defineProperty(extended, key, newValue || currentValue);\n  }, {});\n}\n\n/**\n * Parses user supplied settings objects.\n */\n\nfunction parseSettings(settings) {\n  var object = extend(settings);\n\n  if (object.types || object.split) {\n    // Support `split` as an alias for `types`\n    object.types = object.types || object.split;\n  }\n\n  if (object.absolute || object.position) {\n    // Support `position: absolute` as alias for `absolute: true`\n    object.absolute = object.absolute || /absolute/.test(settings.position);\n  }\n\n  return object;\n}\n\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */\n\nfunction isLength(value) {\n  return typeof value === 'number' && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */\n\n\nfunction isArrayLike(value) {\n  return isObject(value) && isLength(value.length);\n}\n\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */\n\nfunction toArray(value) {\n  if (Array.isArray(value)) return value;\n  if (value == null) return [];\n  return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];\n}\n\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `Document`\n * - `DocumentFragment`\n */\n\nfunction isNode(input) {\n  return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * Flattens nested ArrayLike object (max 2 levels deep)\n */\n\nfunction flatten(obj) {\n  return toArray(obj).reduce(function (result, item) {\n    return result.concat(toArray(item));\n  }, []);\n}\n\n/**\n * Processes target elements for the splitType function. `target` can any\n * of the following types.\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `ArrayLike<HTMLElement>` - A collection of elements (ie NodeList)\n * 4. `Array<HTMLElement | ArrayLike<HTMLElement>>` - An array of elements\n *     and/or collections of elements\n *\n * Returns a flat array of HTML elements. If `target` does not contain any\n * valid elements, returns an empty array.\n *\n * @param {any} target\n * @returns {HTMLElement[]} A flat array HTML elements\n * @example\n *\n * // Single Element\n * const element = document.createElement('div')\n * getTargetElements()\n * // => [element]\n *\n * const nodeList = document.querySelectorAll('div')\n * getTargetElements(nodeList)\n * // => HTMLElement[] (all elements in `nodeList`)\n *\n * const nodeListA = document.querySelectorAll('div')\n * const nodeListB = document.querySelectorAll('p')\n * getTargetElements([nodeListA, nodeListB])\n * // => HTMLElement[] (all elements in `nodeListA` and `nodeListB`)\n *\n * // ID selector\n * getTargetElements('#id')\n * // => HTMLElement[]\n *\n * // Class selector\n * getTargetElements('.text')\n * // => HTMLElement[]\n *\n * // Non element object will not be returned\n * getTargetElements({foo: bar})\n * // => []\n *\n */\n\nfunction getTargetElements(target) {\n  var elements = target; // If `target` is a selector string...\n\n  if (isString(target)) {\n    if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n      // If `target` is an ID, use `getElementById`\n      elements = document.getElementById(target.trim().slice(1));\n    } else {\n      // Else use `querySelectorAll`\n      elements = document.querySelectorAll(target);\n    }\n  }\n\n  return flatten(elements).filter(isNode);\n}\n\n/**\n * Stores data associated with DOM elements. This is a simplified version of\n * jQuery's data method.\n */\n\nfunction Data(owner, key, value) {\n  var data = {};\n  var id = null;\n\n  if (isObject(owner)) {\n    id = owner[Data.expando] || (owner[Data.expando] = ++Data.uid);\n    data = Data.cache[id] || (Data.cache[id] = {});\n  } // Get data\n\n\n  if (value === undefined) {\n    if (key === undefined) {\n      return data;\n    }\n\n    return data[key];\n  } // Set data\n  else if (key !== undefined) {\n      data[key] = value;\n      return value;\n    }\n}\nData.expando = \"splitType\".concat(new Date() * 1);\nData.cache = {};\nData.uid = 0; // Remove all data associated with the given element\n\nfunction RemoveData(element) {\n  var id = element && element[Data.expando];\n\n  if (id) {\n    delete element[id];\n    delete Data.cache[id];\n  }\n}\n\n/**\n * Iterates values of an array or array-like object calling the provided\n * `callback` for each item. Based on `array.forEach`\n * @param {any} collection\n * @param {function} callback\n */\n\nfunction forEach(collection, callback) {\n  var arr = toArray(collection);\n\n  for (var len = arr.length, i = 0; i < len; i++) {\n    callback(arr[i], i, arr);\n  }\n}\n\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */\nfunction toWords(string) {\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';\n  string = string ? String(string) : '';\n  return string.split(separator);\n}\n\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */\nvar rsAstralRange = \"\\\\ud800-\\\\udfff\";\nvar rsComboMarksRange = \"\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\";\nvar rsComboSymbolsRange = \"\\\\u20d0-\\\\u20f0\";\nvar rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */\n\nvar rsAstral = \"[\".concat(rsAstralRange, \"]\");\nvar rsCombo = \"[\".concat(rsComboMarksRange).concat(rsComboSymbolsRange, \"]\");\nvar rsFitz = \"\\\\ud83c[\\\\udffb-\\\\udfff]\";\nvar rsModifier = \"(?:\".concat(rsCombo, \"|\").concat(rsFitz, \")\");\nvar rsNonAstral = \"[^\".concat(rsAstralRange, \"]\");\nvar rsRegional = \"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\";\nvar rsSurrPair = \"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\";\nvar rsZWJ = \"\\\\u200d\";\n/** Used to compose unicode regexes. */\n\nvar reOptMod = \"\".concat(rsModifier, \"?\");\nvar rsOptVar = \"[\".concat(rsVarRange, \"]?\");\nvar rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = \"(?:\".concat([\"\".concat(rsNonAstral).concat(rsCombo, \"?\"), rsCombo, rsRegional, rsSurrPair, rsAstral].join('|'), \"\\n)\");\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\nvar reUnicode = RegExp(\"\".concat(rsFitz, \"(?=\").concat(rsFitz, \")|\").concat(rsSymbol).concat(rsSeq), 'g');\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\nvar unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];\nvar reHasUnicode = RegExp(\"[\".concat(unicodeRange.join(''), \"]\"));\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction asciiToArray(string) {\n  return string.split('');\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\n\n\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction stringToArray(string) {\n  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\n\nfunction toString(value) {\n  return value == null ? '' : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('f\uD83D\uDE00o');\n * // => ['f', '\uD83D\uDE00', 'o']\n *\n * toChars('f-\uD83D\uDE00-o', /-/);\n * // => ['f', '\uD83D\uDE00', 'o']\n *\n */\n\n\nfunction toChars(string) {\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  string = toString(string);\n\n  if (string && isString(string)) {\n    if (!separator && hasUnicode(string)) {\n      return stringToArray(string);\n    }\n  }\n\n  return string.split(separator);\n}\n\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */\n\nfunction createElement(name, attributes) {\n  var element = document.createElement(name);\n\n  if (!attributes) {\n    // When called without the second argument, its just return the result\n    // of `document.createElement`\n    return element;\n  }\n\n  Object.keys(attributes).forEach(function (attribute) {\n    var value = attributes[attribute]; // Ignore attribute if value is `null`\n\n    if (value === null) return; // Handle `textContent` and `innerHTML`\n\n    if (attribute === 'textContent' || attribute === 'innerHTML') {\n      element[attribute] = value;\n    } // Handle `children`\n    else if (attribute === 'children') {\n        forEach(value, function (child) {\n          if (isNode(child)) element.appendChild(child);\n        });\n      } // Handle standard HTML attributes\n      else {\n          element.setAttribute(attribute, String(value).trim());\n        }\n  });\n  return element;\n}\n\n/**\n * Takes a comma separated list of `types` and returns an objet\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */\n\nfunction parseTypes(value) {\n  var types = isString(value) || Array.isArray(value) ? String(value) : '';\n  return {\n    lines: /line/i.test(types),\n    words: /word/i.test(types),\n    chars: /(char)|(character)/i.test(types)\n  };\n}\n\n/**\n * Gets the text content of an HTML element.\n *\n * Optionally, <br> tags can be replaced with a unique string so they can be\n * converted back HTML later on.\n *\n * @param {HTMLElement} element\n * @param {string} BR_SYMBOL\n * @return {string} the text content of the given element\n */\nfunction getTextContent(element, LINE_BREAK_SYMBOL) {\n  var brTag = /<br\\s*\\/?>/g;\n  var textContent = element.textContent;\n\n  if (LINE_BREAK_SYMBOL) {\n    var innerHTML = element.innerHTML;\n    var tempDiv = document.createElement('div');\n    tempDiv.innerHTML = innerHTML.replace(brTag, \" \".concat(LINE_BREAK_SYMBOL, \" \"));\n    textContent = tempDiv.textContent;\n  } // Remove extra white space\n\n\n  return textContent.replace(/\\s+/g, ' ').trim();\n}\n\nvar defaults = {\n  splitClass: '',\n  lineClass: 'line',\n  wordClass: 'word',\n  charClass: 'char',\n  types: 'lines, words, chars',\n  absolute: false,\n  tagName: 'div'\n};\n\nvar createFragment = function createFragment() {\n  return document.createDocumentFragment();\n};\n\nvar createTextNode = function createTextNode(str) {\n  return document.createTextNode(str);\n};\n/**\n * Splits the text content of a single element using the provided settings.\n * There are three possible split types: lines, words, and characters. Each one\n * is optional, so text can be split into any combination of the three types.\n *\n * @param {HTMLElement} element the target element\n * @param {Object} settings\n * @return {{\n *   lines: HTMLElement[],\n *   words: HTMLElement[],\n *   chars: HTMLElement[]\n * }}\n */\n\n\nfunction splitSingleElement(element, settings) {\n  settings = extend(defaults, settings); // The split types\n\n  var types = parseTypes(settings.types); // the tag name for split text nodes\n\n  var TAG_NAME = settings.tagName; // A unique string to temporarily replace <br> tags\n\n  var BR_SYMBOL = \"B\".concat(new Date() * 1, \"R\"); // (boolean) true if position is set to absolute\n\n  var isAbsolute = settings.position === 'absolute' || settings.absolute; // The array of wrapped line elements\n\n  var lines = []; // The array of wrapped words elements\n\n  var words = []; // The array of wrapped character elements\n\n  var chars = []; // The plain text content of the target element\n\n  var splitText;\n  /**------------------------------------------------\n   ** SPLIT TEXT INTO WORDS AND CHARACTERS\n   **-----------------------------------------------*/\n  // `splitText` is a wrapper to hold the HTML structure\n\n  splitText = types.lines ? createElement('div') : createFragment(); // Get the element's text content.\n\n  var TEXT_CONTENT = getTextContent(element, BR_SYMBOL); // Create an array of wrapped word elements.\n\n  words = toWords(TEXT_CONTENT).reduce(function (result, WORD, idx, arr) {\n    // Let `wordElement` be the wrapped element for the current word\n    var wordElement;\n    var characterElementsForCurrentWord; // If the current word is a symbol representing a `<br>` tag,\n    // append a `<br>` tag to splitText and continue to the next word\n\n    if (WORD === BR_SYMBOL) {\n      splitText.appendChild(createElement('br'));\n      return result;\n    } // If splitting text into characters...\n\n\n    if (types.chars) {\n      // Iterate through the characters in the current word\n      // TODO: support emojis in text\n      characterElementsForCurrentWord = toChars(WORD).map(function (CHAR) {\n        return createElement(TAG_NAME, {\n          class: \"\".concat(settings.splitClass, \" \").concat(settings.charClass),\n          style: 'display: inline-block;',\n          textContent: CHAR\n        });\n      }); // push the character nodes for this word onto the array of\n      // all character nodes\n\n      chars = chars.concat(characterElementsForCurrentWord);\n    } // END IF;\n\n\n    if (types.words || types.lines) {\n      // | If Splitting Text Into Words...\n      // | Create an element (`wordElement`) to wrap the current word.\n      // | If we are also splitting text into characters, the word element\n      // | will contain the wrapped character nodes for this word. If not,\n      // | it will contain the `WORD`\n      wordElement = createElement(TAG_NAME, {\n        class: \"\".concat(settings.wordClass, \" \").concat(settings.splitClass),\n        style: \"display: inline-block; position: \".concat(types.words ? 'relative' : 'static'),\n        children: types.chars ? characterElementsForCurrentWord : null,\n        textContent: !types.chars ? WORD : null\n      });\n      splitText.appendChild(wordElement);\n    } else {\n      // | If NOT splitting into words OR lines...\n      // | Append the characters elements directly to splitText.\n      forEach(characterElementsForCurrentWord, function (characterElement) {\n        splitText.appendChild(characterElement);\n      });\n    }\n\n    if (idx !== arr.length - 1) {\n      // Add a space after the word.\n      splitText.appendChild(createTextNode(' '));\n    } // If we not splitting text into words, we return an empty array\n\n\n    return types.words ? result.concat(wordElement) : result;\n  }, []); // 4. Replace the original HTML content of the element with the `splitText`\n\n  element.innerHTML = '';\n  element.appendChild(splitText); // Unless we are splitting text into lines or using\n\n  if (!isAbsolute && !types.lines) {\n    return {\n      chars: chars,\n      words: words,\n      lines: []\n    };\n  }\n  /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/\n  // There is no built-in way to detect natural line breaks in text (when a\n  // block of text wraps to fit its container). To split text into lines, we\n  // have to detect line breaks by checking the top offset of words. This is\n  // why text was split into words first. To apply absolute\n  // positioning, its also necessary to record the size and position of every\n  // split node (lines, words, characters).\n  // To consolidate DOM getting/settings, this is all done at the same time,\n  // before actually splitting text into lines, which involves restructuring\n  // the DOM again.\n\n\n  var wordsInEachLine = [];\n  var wordsInCurrentLine = [];\n  var lineHeight;\n  var elementHeight;\n  var elementWidth;\n  var contentBox;\n  var lineOffsetY; // TODO: Is it necessary to store `nodes` in the cache?\n  // nodes is a live HTML collection of the nodes in this element\n\n  var nodes = Data(element, 'nodes', element.getElementsByTagName(TAG_NAME)); // Cache the element's parent and next sibling (for DOM removal).\n\n  var parent = element.parentElement;\n  var nextSibling = element.nextElementSibling; // get the computed style object for the element\n\n  var cs = window.getComputedStyle(element);\n  var align = cs.textAlign; // If using absolute position...\n\n  if (isAbsolute) {\n    // Let contentBox be an object containing the width and offset position of\n    // the element's content box (the area inside padding box). This is needed\n    // (for absolute positioning) to set the width and position of line\n    // elements, which have not been created yet.\n    contentBox = {\n      left: splitText.offsetLeft,\n      top: splitText.offsetTop,\n      width: splitText.offsetWidth\n    }; // Let elementWidth and elementHeight equal the actual width/height of the\n    // element. Also check if the element has inline height or width styles\n    // already set. If it does, cache those values for later.\n\n    elementWidth = element.offsetWidth;\n    elementHeight = element.offsetHeight;\n    Data(element).cssWidth = element.style.width;\n    Data(element).cssHeight = element.style.height;\n  } // Iterate over every split text node\n\n\n  forEach(nodes, function (node) {\n    if (node === splitText) return;\n    var isWord = node.parentElement === splitText;\n    var wordOffsetY; // a. Detect line breaks by checking the top offset of word nodes.\n    //    For each line, create an array (line) containing the words in that\n    //    line.\n\n    if (types.lines && isWord) {\n      // wordOffsetY is the top offset of the current word.\n      wordOffsetY = Data(node, 'top', node.offsetTop); // If wordOffsetY is different than the value of lineOffsetY...\n      // Then this word is the beginning of a new line.\n      // Set lineOffsetY to value of wordOffsetY.\n      // Create a new array (line) to hold the words in this line.\n\n      if (wordOffsetY !== lineOffsetY) {\n        lineOffsetY = wordOffsetY;\n        wordsInEachLine.push(wordsInCurrentLine = []);\n      } // Add the current word node to the line array\n\n\n      wordsInCurrentLine.push(node);\n    } // b. Get the size and position of all split text nodes.\n\n\n    if (isAbsolute) {\n      // The values are stored using the data method\n      // All split nodes have the same height (lineHeight). So its only\n      // retrieved once.\n      // If offset top has already been cached (step 11 a) use the stored value.\n      Data(node).top = wordOffsetY || node.offsetTop;\n      Data(node).left = node.offsetLeft;\n      Data(node).width = node.offsetWidth;\n      Data(node).height = lineHeight || (lineHeight = node.offsetHeight);\n    }\n  }); // END LOOP\n  // Remove the element from the DOM\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n  /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/\n\n\n  if (types.lines) {\n    // Let splitText be a new document createFragment to hold the HTML\n    // structure.\n    splitText = createFragment(); // Iterate over lines of text (see 11 b)\n    // Let `line` be the array of words in the current line.\n    // Return an array of the wrapped line elements (lineElements)\n\n    lines = wordsInEachLine.map(function (wordsInThisLine) {\n      // Create an element to wrap the current line.\n      var lineElement = createElement(TAG_NAME, {\n        class: \"\".concat(settings.splitClass, \" \").concat(settings.lineClass),\n        style: \"display: block; text-align: \".concat(align, \"; width: 100%;\")\n      }); // Append the `lineElement` to `SplitText`\n\n      splitText.appendChild(lineElement); // Store size/position values for the line element.\n\n      if (isAbsolute) {\n        Data(lineElement).type = 'line'; // the offset top of the first word in the line\n\n        Data(lineElement).top = Data(wordsInThisLine[0]).top;\n        Data(lineElement).height = lineHeight;\n      } // Iterate over the word elements in the current line.\n\n\n      forEach(wordsInThisLine, function (wordElement, idx, arr) {\n        if (types.words) {\n          // | If we are splitting text into words,\n          // | just append each wordElement to the lineElement.\n          lineElement.appendChild(wordElement);\n        } else if (types.chars) {\n          // | If splitting text into characters but not words...\n          // | Append the character elements directly to the line element\n          forEach(wordElement.children, function (charNode) {\n            lineElement.appendChild(charNode);\n          });\n        } else {\n          // | If NOT splitting into words OR characters...\n          // | append the plain text content of the word to the line element\n          lineElement.appendChild(createTextNode(wordElement.textContent));\n        } // Add a space after the word\n\n\n        if (idx !== arr.length - 1) {\n          lineElement.appendChild(createTextNode(' '));\n        }\n      }); // END LOOP\n\n      return lineElement;\n    }); // END LOOP\n    // 10. Insert the new splitText\n\n    element.replaceChild(splitText, element.firstChild);\n  }\n  /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/\n  // Apply absolute positioning to all split text elements (lines, words, and\n  // characters). The size and relative position of split nodes has already\n  // been recorded. Now we use those values to set each element to absolute\n  // position. However, positions were logged before text was split into lines\n  // (step 13 - 15). So some values need to be recalculated to account for the\n  // modified DOM structure.\n\n\n  if (isAbsolute) {\n    // Set the width/height of the parent element, so it does not collapse\n    // when its child nodes are set to absolute position.\n    element.style.width = \"\".concat(element.style.width || elementWidth, \"px\");\n    element.style.height = \"\".concat(elementHeight, \"px\"); // Iterate over all split nodes.\n\n    forEach(nodes, function (node) {\n      var isLineNode = Data(node).type === 'line';\n      var isChildOfLineNode = !isLineNode && Data(node.parentElement).type === 'line'; // Set the top position of the current node.\n      // -> If its a line node, we use the top offset of its first child\n      // -> If its the child of line node, then its top offset is zero\n\n      node.style.top = \"\".concat(isChildOfLineNode ? 0 : Data(node).top, \"px\"); // Set the left position of the current node.\n      // -> If its a line node, this this is equal to the left offset of\n      //    contentBox.\n      // -> If its the child of a line node, the cached valued must be\n      //    recalculated so its relative to the line node (which didn't\n      //    exist when value was initially checked). NOTE: the value is\n      //    recalculated without querying the DOM again\n\n      node.style.left = isLineNode ? \"\".concat(contentBox.left, \"px\") : \"\".concat(Data(node).left - (isChildOfLineNode ? contentBox.left : 0), \"px\"); // Set the height of the current node to the cached value.\n\n      node.style.height = \"\".concat(Data(node).height, \"px\"); //  Set the width of the current node.\n      //  If its a line element, width is equal to the width of the contentBox.\n\n      node.style.width = isLineNode ? \"\".concat(contentBox.width, \"px\") : \"\".concat(Data(node).width, \"px\"); // Finally, set the node's position to absolute.\n\n      node.style.position = 'absolute';\n    });\n  } // end if;\n  // 14. Re-attach the element to the DOM\n\n\n  if (parent) {\n    if (nextSibling) parent.insertBefore(element, nextSibling);else parent.appendChild(element);\n  }\n\n  return {\n    lines: lines,\n    words: types.words ? words : [],\n    chars: chars\n  };\n}\n\nvar _defaults = extend(defaults, {});\n\nvar SplitType = /*#__PURE__*/function () {\n  _createClass(SplitType, null, [{\n    key: \"defaults\",\n\n    /**\n     * The default settings for all splitType instances\n     */\n    get: function get() {\n      return _defaults;\n    }\n    /**\n     * Sets the default settings for all SplitType instances.\n     *\n     * Setting `SplitType.defaults` to an object will merge that object with the\n     * existing defaults.\n     *\n     * @param {Object} settings an object containing the settings to override\n     *\n     * @example\n     * SplitType.defaults = { \"position\": \"absolute\" }\n     */\n    ,\n    set: function set(options) {\n      _defaults = extend(_defaults, parseSettings(options));\n    }\n    /**\n     * Creates a new `SplitType` instance\n     *\n     * @param {any} target The target elements to split. can be one of:\n     *  - {string} A css selector\n     *  - {HTMLElement} A single element\n     *  - {ArrayLike<HTMLElement>} A collection of elements\n     *  - {Array<HTMLElement | ArrayLike<HTMLElement>>} A nested array of elements\n     * @param {Object} [options] Settings for the SplitType instance\n     */\n\n  }]);\n\n  function SplitType(target, options) {\n    _classCallCheck(this, SplitType);\n\n    this.isSplit = false;\n    this.settings = extend(_defaults, parseSettings(options));\n    this.elements = getTargetElements(target) || [];\n\n    if (this.elements.length) {\n      // Store the original HTML content of each target element\n      this.originals = this.elements.map(function (element) {\n        return Data(element, 'html', Data(element).html || element.innerHTML);\n      });\n\n      if (this.settings.types) {\n        // Initiate the split operation.\n        this.split();\n      }\n    }\n  }\n  /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */\n\n\n  _createClass(SplitType, [{\n    key: \"split\",\n    value: function split(options) {\n      var _this = this;\n\n      // If any of the target elements have already been split,\n      // revert them back to their original content before splitting them.\n      this.revert(); // Create arrays to hold the split lines, words, and characters\n\n      this.lines = [];\n      this.words = [];\n      this.chars = []; // cache vertical scroll position before splitting\n\n      var scrollPos = [window.pageXOffset, window.pageYOffset]; // If new options were passed into the `split()` method, update settings\n\n      if (options !== undefined) {\n        this.settings = extend(this.settings, parseSettings(options));\n      } // Split text in each target element\n\n\n      this.elements.forEach(function (element) {\n        // Add the split text nodes from this element to the arrays of all split\n        // text nodes for this instance.\n        var _split2 = splitSingleElement(element, _this.settings),\n            lines = _split2.lines,\n            words = _split2.words,\n            chars = _split2.chars;\n\n        _this.lines = _this.lines.concat(lines);\n        _this.words = _this.words.concat(words);\n        _this.chars = _this.chars.concat(chars);\n        Data(element).isSplit = true;\n      }); // Set isSplit to true for the SplitType instance\n\n      this.isSplit = true; // Set scroll position to cached value.\n\n      window.scrollTo(scrollPos[0], scrollPos[1]); // Clear data Cache\n\n      this.elements.forEach(function (element) {\n        var nodes = Data(element).nodes || [];\n        toArray(nodes).forEach(RemoveData);\n      });\n    }\n    /**\n     * Reverts target element(s) back to their original html content\n     * @public\n     */\n\n  }, {\n    key: \"revert\",\n    value: function revert() {\n      var _this2 = this;\n\n      // Delete the arrays of split text elements\n      if (this.isSplit) {\n        this.lines = null;\n        this.words = null;\n        this.chars = null;\n      } // Remove split text from target elements and restore original content\n\n\n      this.elements.forEach(function (element) {\n        if (Data(element).isSplit && Data(element).html) {\n          element.innerHTML = Data(element).html;\n          element.style.height = Data(element).cssHeight || '';\n          element.style.width = Data(element).cssWidth || '';\n          _this2.isSplit = false;\n        }\n      });\n    }\n  }]);\n\n  return SplitType;\n}();\n\nexport default SplitType;\n", "import d from \"./node_modules/split-type/dist/index.js\";export default d;"],
  "mappings": "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",
  "names": ["createFragment", "createTextNode", "SplitType"]
}
